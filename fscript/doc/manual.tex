\documentclass[a4paper,12pt]{report}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx,alltt,url,geometry,hyperref}
\usepackage[square]{natbib}
\usepackage{syntax}

\newenvironment{rationale}{\textbf{Rationale:}}{}
\newenvironment{note}{\textbf{Note:}}{}

\newcommand{\fixme}[1]{\textit{\textbf{FIXME:} #1}}
\newcommand{\todo}[1]{\textit{\textbf{TODO:} #1}}
%\newcommand{\fixme}[1]{}
%\newcommand{\todo}[1]{}

\newcommand{\interface}[1]{\texttt{#1}}
\newcommand{\function}[1]{\texttt{#1}}
\newcommand{\type}[1]{\texttt{#1}}
\newcommand{\axis}[1]{\texttt{#1}}
\newcommand{\arc}[3]{#1 \stackrel{#2}{\longrightarrow} #3}

\begin{document}

\title{FPath and FScript Reference Manual}
\author{Pierre-Charles David\\\texttt{pcdavid@gmail.com}}

\maketitle
\tableofcontents

\chapter{Introduction}
\label{cha:introduction}

{\large \bf Note: This document is a work in progress. If you have any feedback, please contact
  \texttt{pcdavid@gmail.com}. Thank you.}

\vspace{1em}

\noindent This document is the reference manual for the FPath and FScript Domain-Specific
Languages \citep{david.phd2005}. Both languages are designed to make it easier to deal
with software systems built using the Fractal Component Model
\citep{bruneton-coupaye-stefani.ow2003,bruneton-coupaye-leclercq-al.spe2006}. More
specifically:
\begin{itemize}
\item FPath is a \emph{navigation} language for Fractal architectures. An FPath expression
  is a query which is run against a set of Fractal components, returning the set of
  architectural elements (for example components or interfaces) which match the query.
\item FScript is a language to program architectural \emph{reconfigurations} of Fractal
  systems. It builds upon FPath to select the elements which must be reconfigured, but
  otherwise looks like a simple ``scripting language'', with a few restrictions. These
  restrictions are designed so that it is possible to guarantee that FScript
  reconfigurations are ``well-behaved''.
\end{itemize}

One of the main strengths of the Fractal component model is its support for reflection. In
particular, the model provides standard ways to introspect Fractal components to discover
their internal structure, state and relationships with each other (architecture), and to
reconfigure these dynamically. However, Fractal is specified as a set of APIs, and does
not rely on syntactic extensions to the implementation languages. In addition, these APIs
are designed to be minimal and orthogonal. In practice, this means that using these
``raw'' APIs can quickly lead to writing very verbose and error-prone code. The main goal
of FPath and FScript is to provide more convenient ways to access the full power of the
Fractal model, both for introspection (FPath) and reconfiguration (FScript).

Note that the languages are not designed to implement Fractal component, but to introspect
and manipulate (instantiate, reconfigure) already implemented components. FPath and
FScript only deal with the aspects of components specified in the model. In particular,
they do not expose or allow to manipulate implementation-specific information (e.g. the
internal structure of a membrane) or business-level behaviour and state (except insofar
that this state is exposed using standard Fractal interfaces). The current version of
FScript has the additional limitation that it relies on Fractal ADL descriptors to
instantiate new components dynamically (see~\ref{sec:action:new}). This limitation may be
removed in the future.

This document assumes a good knowledge of the Fractal model. See the reference manual
\citep{bruneton-coupaye-stefani.ow2003} or the official web site at
\path{http://fractal.objectweb.org/} for details about Fractal. Both the definition and
implementation of FPath and FScript are independant on the specifics of a particular
implementation of Fractal (Julia, AOKell\dots), although parts of this specification are
currenlty Java-specific. As both languages make heavy use of Fractal's reflective
capabilities, the current implementation, which is fully interpreted, requires taht
components are compliant with level 3.3 (see page~28 of the specification for the
definition of compliance levels).

This document only describes the languages syntax and semantics. Instructions on how to
use the standard implementation to invoke FPath and FScript programs from Java can be
found in the implementation's Javadoc and in the tutorial on the
web\footnote{\url{http://fractal.objectweb.org/tutorials/fscript/index.html}}, also
available in the project source.

Chapter~\ref{cha:fpath} first describes FPath as a standalone query language.
Chapter~\ref{cha:fscript} then present the full FScript language, which builds on FPath.
% Appendices provide more synthetic presentations of both languages syntaxes and standard
% library of functions and primitive reconfiguration actions.

\chapter{FPath}
\label{cha:fpath}

FPath is an expression language to query live Fractal architectures. By \emph{expression
  language} we mean that FPath is side-effect free: executing an FPath program can not
modify the target system. By \emph{query} we mean that an FPath expression is used to
select architectural elements in a target system according to some criteria. By \emph{live
  Fractal architectures} we mean that FPath is primarily designed to target instanciated
Fractal components, as opposed to static descriptions of such components like Fractal ADL
definitions\footnote{It might be possible to use FPath or a variant of it to query static
  architecture descriptions. This version of the language does not try to support this use
  case.}.

The design objectives of FPath are the following:
\begin{itemize}
\item the syntax should be \emph{simple to read and understand}, and reasonably
  \emph{compact};
\item the language should provide \emph{full access to all the introspection capabilities}
  of the Fractal model. Note however that FPath only deals with components at the
  architecture level, and hence only ``knows'' about concepts defined in the Fractal
  specification. In particular, FPath does not give access to information specific to an
  implementation (e.g. the mixin structure of a Julia membrane) or to the implementation
  code of primitive components;
\item the language (especially its syntax), should be \emph{extensible} to transparently
  support extensions to the Fractal model which are not defined in the base specification.
  By transparently we mean that it should not be possible to distinguish between standard
  features and extensions.
\item the language semantics should be defined at a \emph{high level of abstraction}, to
  be \emph{simple to understand} while supporting \emph{efficient implementations}.
\end{itemize}

Both the syntax and the execution model of FPath are inspired by the XPath
\cite{xpath.w3c1999} language. XPath is the standard query language for XML documents
defined by the W3C, used by many other XML technologies (XLink, XSLT, XQuery...). XPath is
defined on an abstract representation of XML documents as sets of nodes which represent
the content of an XML document (elements, attributes, textual content\dots), and relations
between these nodes which represent its structure (an element contains another, which
itself has some attributes). XPath expressions can navigate along these relations to
select the nodes representing parts of the document based either on their properties or
their location in the document.

The use of XPath as a model for FPath was motivated by the following features:
\begin{itemize}
\item XPath does not depend on the syntax of XML documents, but only on an abstract graph
  model. This makes the approach suitable other graph-like models, in particular component
  architectures.
\item Although XPath defines a fixed set of node types and relations suitable for XML
  documents, the syntax is open-ended and supports the definition of new kinds of nodes
  and relations between them without changing the language. This is important in our case
  to support the same level of extensibility than the Fractal model itself. If a new
  Fractal extension is defined which introduces new architectural elements and/or new
  relations between components (for example an aspect weaving relationship), it should be
  possible to use it in FPath without changing the syntax of the language.
\item XPath expressions can have varying degrees of precision. This make it possible in
  FPath to write very precise expressions, which will locate an element at a specific
  location in an architecture (for example ``the component which implements service S for
  the direct child of composite C1 named C2''), but also more generic and less brittle
  (but also less precise) expressions which will work on a wider range of architectures
  (for example ``any component which provides service S and is contained, directly or not,
  in C1'').
\item The syntax is reasonably consise and readable, and the execution model is simple to
  understand for users while still allowing different implementation strategies.
\end{itemize}

It should be noted that although FPath is \emph{inspired} by XPath, it is not
\emph{implemented} using XPath, and does not use any XML representation of Fractal
architectures.

In addition to the path expressions used to navigate inside the architecture, FPath also
supports more standard kinds of expressions and primitive values, and a standard library
of functions to operate on those % (see~\ref{cha:app:standard-functions})
. In the rest of
this chapter, we first describe primitive values and expressions before going into the
details of nodes and path expressions.

\section{Primitive Values and Expressions}
\label{sec:std-expressions}

\subsection{Numbers and arithmetic operations}
\label{sec:numbers}

FPath supports only one kind of numbers, which correspond to Java's \texttt{double} type.
They have the following litteral syntax:
\begin{grammar}
<number> ::= <opt-sign> <digits> <opt-decimal-part>

<opt-sign> ::= `+' | `-' | <empty>

<digits> ::= <digit> | <digit> <digits>

<opt-decimal-part> ::= `.' <digits> | `.' | <empty>

<digit> ::= `0' | `1' | `2' | `3' | `4' | `5' | `6' | `7' | `8' | `9'
\end{grammar}

Numbers without a decimal part are automatically converted to floating point
representation, and all operations in FPath are done using \texttt{double}s.

Here are a few examples:
\begin{verbatim}
1
-0.0
3.14159
-2.
+42
01234.56789
\end{verbatim}

The four arithmetic operations (addition, substraction, multiplication, division) are
available, with the standard precendence rules, but the division operator is \texttt{div}
instead of \texttt{/} to avoid confusion with the path separator. Their semantics is the
same as in Java, including the treatment of negative zero, infinities, and \textsl{NaN}
results. A division by zero aborts the evaluation of the whole FPath expression with an
error.

\begin{verbatim}
3+4*5        // => 23.0
(3+4)*5      // => 35.0
3 div 4      // =>  0.75
3 * -1.0 + 7 // =>  4.0
\end{verbatim}

\subsection{Strings}
\label{sec:strings}

FPath supports Unicode strings as a base data type, and provides a set of standard
functions to operate on them%  (see~\ref{cha:app:standard-functions},
% page~\pageref{cha:app:standard-functions})
. Both single-quoted and double-quoted string
litterals are supported, with some standard escape characters:
\begin{grammar}
<string> ::= <sq-string> | <dq-string>

<sq-string> ::= `\'' <sq-chars> `\''

<dq-string> ::= `"' <dq-chars> `"'

<sq-chars> ::= <escape> <sq-chars> | <sq-char> <sq-chars> | <empty>

<dq-chars> ::= <escape> <dq-chars> | <dq-char> <dq-chars> | <empty>

<escape> ::= `\\n' | `\\r' | `\\t' | `\\"' | `\\\''
\end{grammar}

where \synt{sq-char} (resp. \synt{dq-char}) is the set of all Unicode characters except
for backslash (\lit{$\backslash$}) and the single-quote character \lit{'} (resp. the
double-quote character \lit{"}).

For example:
\begin{verbatim}
"a simple string"
'another one'
""
'He said "Hello".'
'It\'s not what I expected...\n'
\end{verbatim}

\subsection{Booleans}
\label{sec:booleans}

FPath supports booleans and the corresponding operations. There is no litteral syntax for
boolean values, but they can be obtained by calling the built-in functions \texttt{true()}
and \texttt{false()}.

The boolean operations supported are: conjunction, disjunction and negation. The first two
are supported through the operator \texttt{and} and \texttt{or}, conjunction having a
higher priority. Negation is supported using the predefined function \texttt{not()}.

For example:
\begin{verbatim}
true() and false()                // = false()
true() or false() and true()      // = true()
not(true() and false()) or true() // = true()
\end{verbatim}

\subsection{Variables}
\label{sec:variables}

Although FPath expression can not \emph{define} variables or change variables values, they
can \emph{use} variables defined elsewhere. When using FPath as a standalone query
language, variable definition is done in the calling program using the evaluator's API
(not specified here). When using FPath as part of FScript, variables can be defined and
modified by the enclosing FScript program.

Referencing a variable is done by prefixing its name with a dollar sign (\verb+$+):
\begin{grammar}
<variable> ::= `$' <name> %$
\end{grammar}

Examples of valid variable names include:
\begin{verbatim}
$var
$x3
$a_long_variable_name
$anotherOneInADifferentStyle
$yet-another-style
$_
\end{verbatim}

\subsection{Function calls}
\label{sec:function-calls}

FPath expressions can invoke functions. These functions can be used either to manipulate
primitive values (numbers, strings and booleans) or to introspect node values
(representing elements in the architecture). However, no function call can modify these
architectural elements.

The syntax of function call is the following:
\begin{grammar}
<call> ::= <name> `(' <opt-arguments> `)'

<opt-arguments> ::= <arguments> | <empty>

<arguments> ::= <expression> | <expression> `,' <arguments>
\end{grammar}

For example:
\begin{verbatim}
ends-with("-controller", name($anInterface))
compatible($clItf, $srvItf)
bound($clItf)
\end{verbatim}

\subsection{Opaque Object Values}
\label{sec:opaque-object-values}

Although they do not have a litteral syntax, it is possible for an FPath function to
return a raw value from the underlying implementation language (for example an object in
Java). These values can be stored in variables and used with compatible, user-defined
functions. This is intended to enable convenient extension of the library of functions.
For example, one could imagine an extension to support regular expressions matching:

\begin{verbatim}
re = make-regexp("fo+");
isFoo = matches("foo", $re);
\end{verbatim}%$

Where \texttt{make-regexp} is a user-supplied function which returns a compiled regurlar
expession object as an opaque value which is then used by \texttt{matches}.

None of the predefined functions produces or uses such values.

\subsection{Comparisons}
\label{sec:comp-and-bool}

General equality an inequality tests are available for all primitive and node types, while
ordering oprators are available only for numbers.

\begin{grammar}
<comparison> ::= <equality-test> | <ordering-test>

<equality-test> ::= <expression> `==' <expression> | <expression> `!=' <expression>

<ordering-test> ::= <expression> <ordering-operator> <expression>

<ordering-operator> ::= `<' | `>' | `<=' | `>='
\end{grammar}

For example:
\begin{verbatim}
"foo" != "bar"
name($itf) == "component"
1 + 2 == 3
42 <= 43
\end{verbatim}

\section{Nodes and Path Expressions}
\label{sec:nodes-and-paths}

\subsection{Graph Representation of Fractal Architectures}
\label{sec:graph-model}

A Fractal architecture (i.e. a set of Fractal components) is modeled in FPath as a
directed graph with labeled arcs. The nodes in the graph represent the different kinds of
architectural entities which are visible in FPath, while the labeled arcs represent their
relations. Note that this graph representation is just a model; implementations do not
have to use a graph representation of the architecture as long as they conform to the
language semantics

FPath defines a standard set of node types and their relations, which correspond to the
concepts defined in the Fractal specification. However, neither the semantics nor the
syntax of the language is specific to these particular node types and relations. This is
the very feature which makes FPath extensible in the same way that Fractal is: if a new
model extension is defined, supporting it in FPath amounts only to adding support to the
appropriate new node types and relations. It does not require changes in the syntax or in
the implementation. Indeed, an FPath implementation must support the addition of new types
of nodes and relations without requiring to be modified.

The following subsections describe the standard, predefined node types and relations
(arcs).

\subsection{Nodes}
\label{sec:nodes}

Nodes represent elements of interest in a Fractal architecture. These do not correspond
exactly to the kinds of ``objects'' reified by the Fractal APIs, but more to the concepts
that users want to be able to talk about. For example, Fractal does not have a specific
concept of component: the \texttt{component} interface is just one of the standard control
interfaces (it is \emph{used} to identify components, but it is of the same nature as, for
example, the \texttt{content-controller} interface). In contrast, FPath has a specific
kind of node to represent the components themselves, in addition to the nodes representing
their interfaces (including the \texttt{component} interface).

The standard kinds of nodes supported by FPath are:
\begin{itemize}
\item \emph{component} nodes, which represent the components themselves. Exactly one such
  node exist in the graph for each component in the Fractal architecture it represents.
\item \emph{interface} nodes, which represent the component interfaces. Interface nodes
  are used to represent \emph{all} the interfaces, be they control or service interface,
  client or server, internal or external. Exactly one interface node exist for each
  interface in the architecture. If two components have an ``identical'' interface (for
  example a \texttt{name-controller}), two different nodes are used in the graph.
\item \emph{attribute} nodes, which represent the configuration attributes of the
  components, as defined by their (optional) \texttt{attribute-controller} interface.
  Configuration attributes are not reified explicitely in the Fractal specification, but
  available only through naming conventions -- namely the JavaBeans conventions -- on the
  methods of the \texttt{attribute-controller} interface. One attribute node exist for
  each pair of setter/getter method in this interface.
\end{itemize}

Each node has a name (accessible through the predefined \texttt{name()} function), and
each node type defines how a node can be converted into each of the three primitive value
types (numbers, strings, booleans).

Unless specified otherwise for a particular node type, two nodes are equal (as defined by
the \texttt{=} operator) if and only if they represent the same architectural element.

In the following discussion we will sometimes identify nodes with the architectural
elements they represent for simplicity when there is no risk of confusion.

\subsubsection{Component nodes}
\label{sec:component-nodes}

Component nodes represent the actual Fractal components in the target architecture. They
are different from the interface node which represent their \texttt{component} interface.
Each component in the architecture, whether a primitive, composite or another kind, is
represented by exactly one component node.

The \emph{name} of a component node is defined as:
\begin{enumerate}
\item The value returned by the \texttt{NameController\#getFcName()} method of the
  standard \texttt{name-controller} interface if the component provides this interface (or
  a compatible extension of it).
\item The empty string (\texttt{""}) otherwise.
\end{enumerate}

When converted into a \emph{string}, the value of a component node is the node's name.
When converted into a \emph{boolean}, its value is always \texttt{true()}. Finally, when
converted into a \emph{number}, the value of a component node is Java's
\texttt{Double.NaN} (\textsl{Not a Number}).

The following pre-defined functions give access to additional information on component
nodes:
\begin{itemize}
\item The \texttt{state(\textsl{aCompNode})} function takes a component node in argument
  and returns a string indicating the current lifecycle state of the corresponding
  component. More precisely, it returns:
  \begin{enumerate}
  \item The value returned by the \texttt{\#get\-Fc\-State()} method of the standard
    \texttt{lifecycle-controller} interface if the component provides this interface (or a
    compatible extension of it).
  \item The empty string (\texttt{""}) otherwise.
  \end{enumerate}
\item The \texttt{started(\textsl{aCompNode})} function takes a component node in argument
  and returns \texttt{true()} if \texttt{state(aCompNode) = "STARTED"}, \texttt{false()}
  otherwise.
\item The \texttt{stopped(\textsl{aCompNode})} function takes a component node in argument
  and returns \texttt{true()} if \texttt{state(aCompNode) = "STOPPED"}, \texttt{false()}
  otherwise.
\end{itemize}

\subsubsection{Interface nodes}
\label{sec:interface-nodes}

Interface nodes represent component interfaces. Each interface of each component present
in the architecture, whether it is internal or external, client or server, is represented
by exactly one interface node.

The \emph{name} of an interface node is defined as the result of the
\texttt{Interface\#get\-Fc\-Itf\-Name()} method of the \texttt{Interface} object
representing the component interface.

When converted into a \emph{string}, the value of an interface node is the node's name.
When converted into a \emph{boolean}, its value if always \texttt{true()}. Finally, when
converted into a \emph{number}, the value of an interface node is Java's
\texttt{Double.NaN}.

The following pre-defined functions give access to additional information on interface
nodes:
\begin{itemize}
\item The \texttt{client(\textsl{anItfNode})} function takes a single interface node as
  argument and returns \texttt{true()} if the interface is a client (i.e. required)
  interface, and \texttt{false()} otherwise. More precisely, it returns the same value as
  the Java expression \texttt{((InterfaceType) itf.getFcType()).isFcClientItf()} where
  \texttt{itf} denotes the interface represented by
  \texttt{\textsl{anItfNode}}\footnote{Like most of the functions described in this
    section, this assumes that the type of the interface is (a subtype of) the standard
    \texttt{org.objectweb.fractal.api.type.InterfaceType}.}.
\item The \texttt{server(\textsl{anItfNode})} function takes a single interface node as
  argument and returns \texttt{true()} if the interface is a server (i.e. provided)
  interface, and \texttt{false()} otherwise. It is equivalent to
  \texttt{not(client(anItfNode))}.
\item The \texttt{optional(\textsl{anItfNode})} function takes a single interface node as
  argument and returns \texttt{true()} if the interface is optional, and \texttt{false()}
  otherwise. More precisely, it returns the same value as the Java expression
  \texttt{((InterfaceType) itf.getFcType()).isFcOptionalItf()} where \texttt{itf} denotes
  the interface represented by \texttt{\textsl{anItfNode}}.
\item The \texttt{mandatory(\textsl{anItfNode})} function takes a single interface node
  as argument and returns \texttt{true()} if the interface is mandatory (i.e. not
  optional), and \texttt{false()} otherwise. It is equivalent to
  \texttt{not(optional(\textsl{anItfNode}))}.
\item The \texttt{collection(\textsl{anItfNode})} function takes a single interface node
  as argument and returns \texttt{true()} if the interface is a collection interface, and
  \texttt{false()} otherwise (if it is a single interface). More precisely, it returns the
  same value as the Java expression \texttt{((InterfaceType)
    itf.get\-Fc\-Type()).is\-Fc\-Collection\-Itf()} where \texttt{itf} denotes the interface
  represented by \texttt{\textsl{an\-Itf\-Node}}.
\item The \texttt{single(\textsl{anItfNode})} function takes a single interface node as
  argument and returns \texttt{true()} if the interface is a single interface (i.e. not
  collection), and \texttt{false()} otherwise. It is equivalent to
  \texttt{not(collection(\textsl{anItfNode}))}.
\item The \texttt{internal(\textsl{anItfNode})} function takes a single interface node as
  argument and returns \texttt{true()} if the interface is an internal interface, and
  \texttt{false()} otherwise (if it is an external interface). More precisely, it returns
  the same value as the Java expression \texttt{itf.isFcInternalItf()} where \texttt{itf}
  denotes the interface represented by \texttt{\textsl{anItfNode}}.
\item The \texttt{external(\textsl{anItfNode})} function takes a single interface node as
  argument and returns \texttt{true()} if the interface is an external interface, and
  \texttt{false()} otherwise (if it is an internal interface). It is equivalent to
  \texttt{not(internal(\textsl{an\-Itf\-Node}))}.
\item The \texttt{signature(\textsl{anItfNode})} function takes a single interface node
  as argument and returns a string representing the fully qualified name of the Java
  interface implemented (or required) by the interface. More precisely, it returns the
  same value as the Java expression \texttt{((InterfaceType)
    itf.get\-Fc\-Type()).get\-Fc\-Itf\-Signature()} where \texttt{itf} denotes the interface
  represented by \texttt{\textsl{anItfNode}}.
\item The \texttt{bound(\textsl{anItfNode})} function takes a single interface node as
  argument and returns \texttt{true()} if the interface is a client interface and it is
  currently bound to (at least) one server interface, and \texttt{false()} otherwise.
\item The \texttt{compatible(\textsl{anItfNode1}, \textsl{anItfNode2})} function takes two
  interface nodes as parameters and returns \texttt{true()} if:
  \begin{enumerate}
  \item \texttt{\textsl{anItfNode1}} is a client interface;
  \item \texttt{\textsl{anItfNode2}} is a server interface;
  \item it would be possible to create a direct binding from \texttt{\textsl{anItfNode1}}
    to \texttt{\textsl{anItfNode2}} (see \citep{bruneton-coupaye-stefani.ow2003} for the
    detailed conditions).
  \end{enumerate}
  The function returns \texttt{false()} otherwise.
\end{itemize}

\subsubsection{Attribute nodes}
\label{sec:attribute-nodes}

Attribute nodes represent configuration attributes/parameters of Fractal components, as
exposed through the standard \interface{attribute-controller} interface. These attributes
are not explicitely reified by the Fractal model, as they are only defined through method
naming convention. However, as they provide one of the main ways to dynamically configure
components, FPath represents them explicitely.

If a component does not provide the standard \interface{attribute-controller} interface,
it does not contribute any attribute node.

\fixme{The following description is badly worded, and does not support read-only
  attributes.} Given a component which provides the standard
\interface{attribute-con\-trol\-ler} interface, let \type{T} be the signature of that
interface (i.e. \type{T} is a Java interface type which extends
\type{AttributeController}). Each pair of methods of \type{T} of the form
\texttt{\textsl{V} get\textsl{X}()} / \texttt{void set\textsl{X}(\textsl{V})} or
\texttt{\textsl{B} is\textsl{X}()} / \texttt{void set\textsl{X}(\textsl{B})}, where
\texttt{\textsl{X}} is a valid Java identifier, \texttt{\textsl{V}} represents any Java
type (including primitive types) and \texttt{\textsl{B}} represents either \type{boolean}
or \type{Boolean}, defines one attribute node. The name of this attribute node is the
identifier \texttt{\textsl{X}} where the first character (always a letter) is converted to
lower case. If for some identifier \texttt{\textsl{X}} the three methods
\texttt{\textsl{B} is\textsl{X}()}, \texttt{\textsl{B} get\textsl{X}()} and \texttt{void
  set\textsl{X}(\textsl{B})} exist, only one attribute node represents the attribut
\texttt{\textsl{X}}.

\todo{The Fractal specification supports write-only attributes (see p.~13). Should we
  support these too? Are there any cases when they might be useful?}

When converted into a \emph{string}, the value of an attribute node is the node's name.
When converted into a \emph{boolean}, its value if always \texttt{true()}. Finally, when
converted into a \emph{number}, the value of an attrubute node is Java's
\texttt{Double.NaN}.

The following pre-defined functions give access to additional information on attribute
nodes:
\begin{itemize}
\item The \function{value(\textsl{anAttrNode})} function takes a single attribute node as
  argument and returns the current value of the corresponding attribute. More precisely,
  if the name of the attribute node is \texttt{\textsl{x}}, the \function{value()} returns
  the same value as the following Java expression:
\begin{verbatim}
((T) c.getFcInterface("attribute-controller")).getX()
// or
((T) c.getFcInterface("attribute-controller")).isX()
\end{verbatim}
  where:
  \begin{itemize}
  \item \texttt{c} is the \interface{component} interface of the component which
    contributed \texttt{\textsl{an\-Attr\-Node}};
  \item \type{T} is the actual type of that component's \interface{attribute-controller};
  \item \texttt{X} is the capitalized version of the attribute's name.
  \end{itemize}
\end{itemize}

\subsection{Axes}
\label{sec:axes}

The different kinds of nodes defined in the previous section represent the individual
elements which are visible in FPath. The \emph{structure} of the application, i.e. its
architecture, is represented by how these elements are connected to each other in a
oriented graph. Each arc in the graph is annotated by a label which denotes a particular
relation between the two nodes it connects. The different possible relations between nodes
are called \emph{axes}, and each is identified by a label. FPath defines a standard set of
axes which include all the relations defined in the Fractal specification which can exist
between the pre-defined node types. As for node types, the set of available axes can be
extended without changing the language syntax or semantics to take into account extensions
to the Fractal model.

\begin{itemize}
\item The \axis{component} axis connects every single node (including component nodes) to
  the component node which represent their ``owner'' Fractal component.
\item The \axis{interface} axis connects component nodes to the interface nodes which
  represent external interfaces of the corresponding component.
\item The \axis{internal-interface} axis connects component node to the interface nodes
  which represent internal interfaces of the corresponding component.
\item The \axis{attribute} axis connects component node to the attribute nodes which
  represent configuration attributes of the corresponding component.
\item The \axis{binding} axis connects client interface nodes to the server interface node
  they are bound to, if any.
\item The \axis{child} axis connects component nodes representing composites to the
  component nodes representing their direct sub-components. The \axis{child-or\--self} axis
  is a superset of the \axis{child} axis which also connects each component node to
  itself.
\item The \axis{parent} axis connects component nodes to the component nodes representing
  their direct parents. The \axis{parent-or-self} axis is a superset of the \axis{parent}
  axis which also connects each component node to itself.
\item The \axis{descendant} axis is the transitive closure of the \axis{child} axis. It
  connects a given component node to all the components it contains, directly or
  indirectly (including itself in the case of \axis{descendant-or-self}).
\item The \axis{ancestor} axis is the transitive closure of the \axis{parent} axis. The
  \axis{ancestor} axis connects a given component node to all its direct or indirect
  parents.
\item The \axis{sibling} axis connects a component node to all the components which share
  at least one direct parent with it, i.e. all the components which are ``at the same
  level'' in the architecture.
\item The \axis{descendant-or-self}, \axis{ancestor-or-self}, and \axis{sibling-or-self}
  axes are variants of respectively \axis{descendant}, \axis{ancestor}, and \axis{sibling}
  which also connect the origin component node to itself.
\end{itemize}

\subsection{Nodesets}
\label{sec:nodesets}

A nodeset is a set of node values of the same type (i.e. only component nodes, or
attribute nodes, but not component and attribute nodes in the same set). Nodesets are used
to offer aggregate operations and avoid explicit loops. For example, path expressions
(described in the next section) take nodesets as input and produce nodesets. Functions
can also take nodesets as arguments and produce nodesets as a result.

When a single node value is present in a context where a nodeset value is expected, the
node is automatically wrapped in a singleton nodeset. On the other hand, when a nodeset is
present in a context where a single node value is expected, then:
\begin{itemize}
\item if the nodeset is a singleton, the node it contains is automatically unwrapped;
\item otherwise, the behaviour depends on the operator or function which expected the node
  value. It can either:
  \begin{itemize}
  \item abort with an error;
  \item if the nodeset is non-empty, select one of the node (based on any criteria) to use
    as the value to operate on;
  \item apply itself repeatedly for each of the values in the nodeset (providing an
    implicit loop).
  \end{itemize}
\end{itemize}

\fixme{This irregular behaviour in how nodeset conversion is handled is very bad design.
  It should be fixed in future versions of the language.}

\subsection{Path Expressions}
\label{sec:path-expressions}

Path expressions are used to navigate inside the graph structure described in the previous
sections. A path is evaluated relative to an \emph{initial nodeset}, and produces a
\emph{result nodeset} containing the architectural elements matching the query. This
evaluation is a multi-step process, each step producing an intermediate nodeset result,
which is then used as input to the next step, if any, or as the final result for the last
step. Each step is itself (conceptually) split into up to three phases:
\begin{enumerate}
\item \emph{selection} of a set of candidate nodes, by navigating inside the graph, from
  each of the initial nodes along a specified axis;
\item (optional) \emph{testing} of the candidate nodes on their names;
\item (optional) \emph{filtering} of the matching candidates using predicate expressions.
\end{enumerate}
The set of candidate nodes which match both the name test and all the predicates is the
result nodeset for that step.

\subsubsection{Syntax}
\label{sec:path-syntax}

A path expression is made of an initial, non-path, expression whose value will be the
initial nodeset, and a sequence of at least one step, each prefixed by a slash character:
\begin{grammar}
<path> ::= <expression> <steps>

<steps> ::= `/' <step> | `/' <step> <steps>
\end{grammar}

Each step is itself made of two to three parts: an \emph{axis specifier}, a \emph{test},
and an optional sequence of \emph{predicates}:
\begin{grammar}
<step> ::= <axis> `::' <test> <opt-predicates>

<axis> ::= <name>

<test> ::= `*' | <name>

<opt-predicates> ::= <empty> | <predicates>

<predicates> ::= `[' <expression> `]' | `[' <expression> `]' <predicates>
\end{grammar}

Syntaxically, the axis specifier can be any valid identifier. This is what makes FPath
extensible in terms of the node types and relations it can handle. Although this
specification defines a fixed set of predefined axes (\axis{component},
\axis{child}\dots), the language can handle extensions to the Fractal model which define
new relations between components. For example, one could define an \axis{aspect} axis
which connects base components to aspect components \cite{pessemier.misc2006} which
affects them without requiring changes to the FPath language syntax or semantics.

\subsubsection{Semantics}
\label{sec:path-semantics}

Given a step of the from \texttt{$axis$::$test$[$pred_1$]...[$pred_n$]} and $current$ the
initial nodeset, the result nodeset produced by this step is computed by the following
algorithm:
\begin{description}
\item[S1.] [Initialisation] $result \leftarrow \emptyset$.
\item[S2.] [Selection] Select every node connected to any of the current ones through an
  arc whose label matches the $axis$ part: $result \leftarrow \bigcup\, \{ n : c\,
  \stackrel{axis}{\longrightarrow}\, n, c \in current \}$.
\item[S3.] [Test] If the $test$ is an identifier (as opposed to \texttt{*}), remove from
  $result$ the nodes whose name do not match: $result \leftarrow \{ n \in result : name(n)
  = test \}$.
\item[S4.] [Filtering] Only keep the elements for which all predicates hold: $result
  \leftarrow \{ x \in result : pred_1(x) \wedge \cdots \wedge pred_n(x) \}$.
\item[S5.] [End] The algorithm finishes and returns $result$.
\end{description}

Given a full path of the form \texttt{$expr$/$step_1$/.../$step_n$}, the result nodeset
produced by the full path is computed by the following algorithm:
\begin{description}
\item[P1.] [Initialisation] Evaluate the initial expression $expr$, which must produce a
  nodeset and put the result in $current$ (if $expr$ produces a single node, it is
  automatically converted into a singleton nodeset first). $i \leftarrow 1$.
\item[P2.] [Step] Evaluate $step_i$ using algorithm S above, using $current$ as the
  initial nodeset, and put back the result into $current$.
\item[P3.] [Loop] Increment $i$: $i \leftarrow i + 1$. If $i \leq n$, goto P2.
\item[P4.] [End] The algorithm finishes and returns $current$ as the value of the full
  path expression.
\end{description}

\chapter{FScript}
\label{cha:fscript}

\section{Procedures Definitions}
\label{sec:proc-def}

An FScript program is made of a sequence of top-level procedure definitions. FScript
supports two kinds of procedures: \emph{functions} and \emph{actions}. Functions can only
use introspection features and are hence guaranteed to be side-effect free. They can be
used in FPath expression (for example in predicates) to supplement the standard library of
FPath functions. Actions on the other hand are allowed to modify the target architecture.
Concretely, the body of a function can use only other functions (be they predefined FPath
functions or user-supplied), while actions can make use of functions and other actions
(primitives or user-defined).

The only syntaxic difference between functions and actions appears in their definitions
(Note: maybe we should change this to make it clearer by reading source code which calls
correspond to pure functions or actions. Maybe something like the \texttt{mutation!}
convention used by Scheme. On the other hand maybe this would make FScript code too ugly
and actually harder to read). Functions are introduced by the keyword \texttt{function}
while actions use the keyword \texttt{action}:

\begin{verbatim}
function my-function(<parameters>) { <body> }

action   my-action(<parameters>) { <body> }
\end{verbatim}

Recursive definitions, direct or indirect, are forbidden:
\begin{verbatim}
function f()  { ...; f(); ...; } // ERROR: direct recursiion

function f1() { ...; f2(); ... }
function f2() { ...; f1(); ... } // ERROR: indirect recursiion
\end{verbatim}

Inside the body of a procedure, the values of the arguments are available as variables
with names matching the parameter names in the signature:
\begin{verbatim}
action do-something(x, y) {
  do-this($x);
  do-that($y);
}
\end{verbatim}

\section{Control Structures}
\label{sec:control-structures}

FScript procedures support a limited set of control structures so that it is possible to
ensure that they will enventually terminate (there is no bound on the time they can take
however).

\subsection{Variables Assignment}
\label{sec:assignment}

New local variables can be created inside the body simply by assigning them an initial
value:
\begin{verbatim}
x = <some-expression>;
\end{verbatim}

Variable values can be changed simply by re-assigning them:
\begin{verbatim}
x = <some-expression>;
... // do something with $x
x = <another-expression>;
... // do something else with the new value of $x
\end{verbatim}

Invocation parameters behave exactly like local variable except that they are
automatically assigned before entering the body of the procedure. In particular, this
means their value can be reassigned:
\begin{verbatim}
action f(x) {
  do-something($x);
  x = ...;
  do-something-else($x);
}
\end{verbatim}

\fixme{Would there be any advantages to forbid the redefinition of variable?}

\todo{It would probably be a good idea to have a \texttt{var v = ...;} statement to
  explicitely introduce new variables as it would catch some typos. It could be optional
  at first, with a simple warning when a variable is created without using it.}

\subsection{Sequence and Blocks}
\label{sec:sequence}

Sequences of instructions can be grouped in blocks, where each instruction is ended by a
semicolon \lit{;}. Blocks themselves are enclosed in braces \verb+{ ... }+. Blocks can not
be introduced anywhere where an instruction is expected; the FScript grammar uses blocks
only at certain points:
\begin{itemize}
\item the body of a procedure must be a block;
\item the ``then'' and ``else'' parts of a conditional must be blocks;
\item the body of an iteration must be a block.
\end{itemize}

\subsection{Conditionals}
\label{sec:conditionals}

Conditional execution is supported using the following two constructs:
\begin{verbatim}
if (<test>) {
  <block-body>
}

if (<test>) {
  <block-body>
} else {
  <block-body>
}
\end{verbatim}
where \verb+<test>+ must be an FPath expression (i.e. it can not be an action invocation,
which can have side-effects). The test expression is first evaluated, and its result
converted into a boolean value. If it is \emph{true}, the \texttt{then} block is
exectuded. If it is \emph{false}, the first construct does nothing, while the second
executes the \texttt{else} block.

\subsection{Iteration}
\label{sec:iteration}

FScript supports a restricted form of iteration, which ensures that the execution will
always terminate. The \texttt{foreach} construct executes a given block repeatedly with a
local iteration variable successively bound to each element in a nodeset (which is always
finite):

\begin{verbatim}
for <var> : <expression> {
  <block-body>
}
\end{verbatim}

The \texttt{<expression>} must evaluate to a nodeset (or a single node value which will be
automatically converted to a singleton nodeset). The body of the block is executed exactly
once for each node in the nodeset, with the corresponding value bound to \texttt{<var>}.

\subsection{Explicit return}
\label{sec:explicit-return}

At any point during its execution, a procedure can stop its execution and immediatly
return to the caller, optionally yielding a value, using a \texttt{return} statement:

\begin{verbatim}
return;
return <expression-or-action>;
\end{verbatim}

\section{Primitive Actions}
\label{sec:primitive-actions}

FScript includes a standard library of primitive actions which correspond to all the
reconfiguration actions defined in the Fractal specification
\citep{bruneton-coupaye-stefani.ow2003}. This library can of course be extended to support
new operations introduced by extension to the model. For example, one could imagine new
primitives to support weaving and unweaving of \emph{aspect components} as supported by
FAC \citep{pessemier-seinturier-duchien-barais.jfdlpa2004}.

An implementation of FScript must provide a standard way to add new primitive operations.

The rest of this section describes all the primitive actions included in the standard
library.%  Appendix~\ref{cha:app:standard-actions} provides a more synthetic list of these
% for easy reference.

\todo{For each action: be more explicit on the error conditions, and show the equivalent
  Java code.}

\subsection{Changing attribute values: \texttt{set-value()}}
\label{sec:action:set-value}

The \texttt{set-value(\textsl{attr}, \textsl{value})} primitive action is used to change
the value of a component's attribute. It takes two parameters:
\begin{itemize}
\item \texttt{\textsl{attr}} is an FPath expression which must evaluate to a non-empty
  nodeset containing attribute nodes;
\item \texttt{\textsl{value}} is an FPath expression which must evaluate to a basic value
  (i.e. not a node or a nodeset).
\end{itemize}

As mentioned earlier (Sec.~\ref{sec:numbers}), FPath, and hence FScript, normally only
deals with floating point numbers. The only exception is when a numeric value is used to
set the value of a Fractal component attribute: if the attribute's type (as defined by the
signature of the corresponding \emph{setter} method in the components
\texttt{attribute-controller}) is an integral type\footnote{Java's integral type are
  \texttt{byte}, \texttt{short}, \texttt{int}, \texttt{long} and \texttt{char}
  \citep[Sect.~4.2.2, p.~36]{gosling-joy-steele-bracha.book2005}}, or a corresponding
\emph{wrapper} reference type, the number's value is automatically converted into the
appropriate type. This conversion is done using the method
\texttt{Number.\textit{x}Value()}, where \texttt{\textit{x}} is the target integral type
(i.e. \texttt{byte}, \texttt{short}\dots).

\subsection{Creating bindings between interfaces: \texttt{bind()}}
\label{sec:action:bind}

The \texttt{bind(\textsl{clitf}, \textsl{srvitf})} primitive action is used to bind a
client interface to a compatible server interface. It corresponds to the
\texttt{bindFc(string, any)} method of the standard \texttt{BindingController} interface
(see \citep[Sec.~4.3, p.~14]{bruneton-coupaye-stefani.ow2003}).

\subsection{Destroying bindings between interfaces: \texttt{unbind()}}
\label{sec:action:unbind}

The \texttt{unbind(\textsl{clitf})} primitive action is used to destroy a binding from
client interface to a server interface. It corresponds to the \texttt{unbindFc(string)}
method of the standard \texttt{BindingController} interface (see \citep[Sec.~4.3,
p.~14]{bruneton-coupaye-stefani.ow2003}).

\subsection{Adding sub-components to composites: \texttt{add()}}
\label{sec:action:add}

The \texttt{add(\textsl{parent}, \textsl{child})} primitive action is used to add a new
sub-component to a composite component. It corresponds to the
\texttt{addFcSubComponent(Component)} method of the standard \texttt{ContentController}
interface (see \citep[Sec.~4.4, p.~15]{bruneton-coupaye-stefani.ow2003})

\subsection{Removing sub-components from composites: \texttt{remove()}}
\label{sec:action:remove}

The \texttt{remove(\textsl{parent}, \textsl{child})} primitive action is used to remove a
sub-component from a composite component. It corresponds to the
\texttt{remove\-Fc\-Sub\-Component()} method of the standard \texttt{Content\-Controller}
interface (see \citep[Sec.~4.4, p.~16]{bruneton-coupaye-stefani.ow2003})

\subsection{Changing a component name: \texttt{set-name()}}
\label{sec:action:set-name}

Text \texttt{set-name(\textsl{comp}, \textsl{name}} primitive action is used to change the
name of a component, as defined by its \texttt{name-controller} interface. If the
component denoted by \texttt{\textsl{comp}} does not implement \texttt{name-controller},
calling \texttt{set-name()} results in an error. Otherwise, it corresponds to the
\texttt{setFcName(String)} method of the standard \texttt{NameController} interface (see
\citep[Sec.~4.4, p.~17]{bruneton-coupaye-stefani.ow2003}).

\subsection{Starting a component: \texttt{start()}}
\label{sec:action:start}

The \texttt{start(\textsl{comp})} primitive action is used to ensure that the component
passed in argument is in the \texttt{STARTED} state. If the component denoted by
\texttt{\textsl{comp}} does not implement \texttt{lifecycle-controller}, calling
\texttt{start()} results in an error. Otherwise, it corresponds to the \texttt{startFc()}
method of the standard \texttt{LifeCycleController} interface (see \citep[Sec.~4.5,
p.~17]{bruneton-coupaye-stefani.ow2003}).

\subsection{Stopping a component: \texttt{stop()}}
\label{sec:action:stop}

The \texttt{stop(\textsl{comp})} primitive action is used to ensure that the component
passed in argument is in the \texttt{STOPPED} state. If the component denoted by
\texttt{\textsl{comp}} does not implement \texttt{lifecycle-controller}, calling
\texttt{stop()} results in an error. Otherwise, it corresponds to the \texttt{stopFc()}
method of the standard \texttt{LifeCycleController} interface (see \citep[Sec.~4.5,
p.~17]{bruneton-coupaye-stefani.ow2003}).

\subsection{Instantiating new components: \texttt{new()}}
\label{sec:action:new}

The \texttt{new(\textsl{tmplName})} primitive action is used to instanciate a new
component. Its argument \texttt{\textsl{tmplName}} must be the fully qualified name of a
Fractal ADL component definition, as a string, and returns a component node representing
the newly instanciated component (this action is the only pre-defined action which returns
a value). It corresponds to the \texttt{newComponent(String, Map)} method of the Fractal
ADL \texttt{Factory} interface, the second parameter being \texttt{null}\footnote{Future
  versions of FScript may provide more control on the instanciation process, and perhaps
  independance from Fractal ADL definitions.}.

\begin{verbatim}
// Fscript
c = new("com.myapp.SomeComponent");
\end{verbatim}

\begin{verbatim}
// Java
Factory fact = FactoryFactory.getFactory(FRACTAL_BACKEND);
Component c = fact.newComponent("com.myapp.SomeComponent", null);
\end{verbatim}

\bibliographystyle{plainnat}
\bibliography{references}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% fill-column: 90
%%% End:
